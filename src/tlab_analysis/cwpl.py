from __future__ import annotations

import dataclasses
import io
import os

import numpy as np
import pandas as pd

DEFAULT_METADATA = [
    "4300\r\n",
    "5300\r\n",
    '"                                                                "\r\n',
    "0\r\n",
    "0\r\n",
    "0\r\n",
    '"                                                                                                                                                                                                                                                                "\r\n',  # noqa: E501
    "501\r\n",
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
]


def read_file(
    filepath_or_buffer: str | os.PathLike[str] | io.BufferedIOBase,
) -> CWPLData:
    """
    Reads a file of data generated by HR320.

    Parameters
    ----------
    filepath_or_buffer : str | os.PathLike[str] | io.BufferedIOBase
        The path to a raw binary or buffer from u8167.

    Returns
    -------
    tlab_analysis.cwpl.CWPLData
        A CWPLData object from the file.

    Raises
    ------
    ValueError
        If `filepath_or_buffer` is invalid.
    """
    if isinstance(filepath_or_buffer, (str, os.PathLike)):
        with open(filepath_or_buffer, "rb") as f:
            return _read_file(f)
    elif isinstance(filepath_or_buffer, io.BufferedIOBase):
        return _read_file(filepath_or_buffer)
    else:
        raise ValueError(
            f"Invalid type for filepath_or_buffer: {type(filepath_or_buffer)}"
        )


def _read_file(file: io.BufferedIOBase) -> CWPLData:
    metadata = [file.readline().decode(CWPLData.HR320.encoding) for _ in range(18)]
    with io.BytesIO(file.read()) as f:  # This with block is for passing mypy
        df = pd.read_csv(
            f,
            header=0,
            encoding=CWPLData.HR320.encoding,
            usecols=[1, 2],
            names=["grating", "intensity"],
            quotechar="'",
        )
    data = CWPLData(df, metadata)
    return data


@dataclasses.dataclass(frozen=True)
class CWPLData:
    """
    Data class for continuous wave photo luminescence measurement.

    Examples
    --------
    Create a dataframe of data.
    >>> grating = np.arange(4000, 4010, dtype=np.int64)
    >>> np.random.seed(0)
    >>> intensity = np.random.random(grating.size)
    >>> df = pd.DataFrame(
    ...     dict(
    ...         grating=grating,
    ...         intensity=intensity,
    ...     )
    ... )

    Create a CWPLData object.
    >>> data = CWPLData(df)
    >>> data.df
       grating  intensity
    0     4000   0.548814
    1     4001   0.715189
    2     4002   0.602763
    3     4003   0.544883
    4     4004   0.423655
    5     4005   0.645894
    6     4006   0.437587
    7     4007   0.891773
    8     4008   0.963663
    9     4009   0.383442

    Access each column.
    >>> data.grating
    0    4000.0
    1    4001.0
    2    4002.0
    3    4003.0
    4    4004.0
    5    4005.0
    6    4006.0
    7    4007.0
    8    4008.0
    9    4009.0
    Name: grating, dtype: float64
    >>> data.intensity
    0    0.548814
    1    0.715189
    2    0.602763
    3    0.544883
    4    0.423655
    5    0.645894
    6    0.437587
    7    0.891773
    8    0.963663
    9    0.383442
    Name: intensity, dtype: float64

    Get wavelength and caribrated wavelength.
    >>> data.wavelength
    0    400.0
    1    400.1
    2    400.2
    3    400.3
    4    400.4
    5    400.5
    6    400.6
    7    400.7
    8    400.8
    9    400.9
    Name: grating, dtype: float64
    >>> data.wavelength_caribrated
    0    386.64700
    1    386.75173
    2    386.85646
    3    386.96119
    4    387.06592
    5    387.17065
    6    387.27538
    7    387.38011
    8    387.48484
    9    387.58957
    Name: grating, dtype: float64
    """

    df: pd.DataFrame
    """A dataframe of the measurement."""
    metadata: list[str] = dataclasses.field(
        default_factory=lambda: list(DEFAULT_METADATA)
    )
    """Meta information of the data from HR320."""

    @dataclasses.dataclass(frozen=True)
    class HR320:
        encoding: str = "cp932"

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, CWPLData):
            return all(
                (
                    (self.df == __o.df).all(axis=None),
                    self.metadata == __o.metadata,
                )
            )
        else:
            return NotImplemented  # pragma: no cover

    @property
    def wavelength(self) -> pd.Series[float]:
        """
        A series of wavelength in nanometer.
        """
        return self.grating / 10

    @property
    def wavelength_caribrated(self) -> pd.Series[float]:
        """
        A series of caribrated wavelength in nanometer.
        """
        return 1.0473 * self.wavelength - 32.273

    @property
    def grating(self) -> pd.Series[float]:
        """
        A series of grating in 10 × nanometer.
        """
        column_name = "grating"
        assert column_name in self.df.columns, (
            f"The column named `{column_name}` doesn't exist in CWPLData.df"
        )
        return self.df[column_name].astype(float)

    @property
    def intensity(self) -> pd.Series[float]:
        """
        A series of intensity in arbitrary units.
        """
        column_name = "intensity"
        assert column_name in self.df.columns, (
            f"The column named `{column_name}` doesn't exist in CWPLData.df"
        )
        return self.df[column_name].astype(float)

    def to_raw_binary(self) -> bytes:
        """
        Converts to a raw binary that HR320 generates.

        Returns
        -------
        bytes
            A raw binary that HR320 generates.
        """
        df = pd.DataFrame(
            {
                "": None,
                "x (cm)": self.grating.map(lambda x: "{0:.3f}".format(x)),
                "強度1 (mv)": self.intensity.map(lambda x: "{0:.4E}".format(x)),
                "強度2 (mV)": pd.Series(np.zeros(self.grating.size)).map(
                    lambda x: "{0:.4E}".format(x)
                ),
            }
        )
        raw_binary = (
            "".join(self.metadata)
            + "".join(
                f'"{line}"\r\n'
                for line in df.to_csv(
                    index=False,
                ).splitlines()
            )
        ).encode(self.HR320.encoding)
        return raw_binary
